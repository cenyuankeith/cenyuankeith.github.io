{"meta":{"title":"Keith Wang的个人博客","subtitle":null,"description":null,"author":"Keith Wang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"mysql知识点记录","slug":"mysql知识点记录","date":"2017-06-22T02:47:04.000Z","updated":"2017-06-22T03:13:11.000Z","comments":true,"path":"2017/06/22/mysql知识点记录/","link":"","permalink":"http://yoursite.com/2017/06/22/mysql知识点记录/","excerpt":"","text":"MySql中in和or比较在很多的数据库系统中，IN()完全等同于多个OR条件的子句，因为这两者是完全等价的，在MySql中这点是不成立的，MySql将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个O(log n)复杂度的操作，等价地转换成OR查询的复杂度为O(n),对于IN()列表中的大量取值的时候，MYSQL的处理速度将会更快。——&lt;&lt;高性能的MySQL&gt;&gt; page 213。","categories":[],"tags":[]},{"title":"618促销哪种方式更便宜","slug":"618促销哪种方式更便宜","date":"2017-06-21T09:20:52.000Z","updated":"2017-06-21T09:28:39.000Z","comments":true,"path":"2017/06/21/618促销哪种方式更便宜/","link":"","permalink":"http://yoursite.com/2017/06/21/618促销哪种方式更便宜/","excerpt":"","text":"今天一个朋友问我一个问题，京东618搞活动，有两种促销方式 买3件商品，商品打7折 买3件商品，最便宜的一件免单 推算出来阀值是在最小商品价格3/7位置代码测试一波: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.math.BigDecimal;public class App &#123; public static void main( String[] args ) &#123; System.out.println( \"Hello World!\" ); /** * 推算：假设最小商品价格为z,其余商品价格为x,y * (x+y+z)*0.7 x+y * (a+z)*0.7 a * 7a+7z 10a * 7z 3a * */ print(3, 3.5, 3.5); print(3, 3.6, 3.4); print(3, 3.5, 3.7); print(3, 3.4, 3.4); &#125; private static void print(double x, double y, double z)&#123; System.out.println(\"商品价格: \" +x +\",\" +y+\", \"+z); double price = price1(x, y, z); double price2 = price2(x, y, z); System.out.println(\"打七折：\"+price+\", 最便宜免单：\"+price2); if(price &gt; price2)&#123; System.out.println(\"最便宜免单划算\"); &#125; else if(price == price2)&#123; System.out.println(\"一样划算\"); &#125; else&#123; System.out.println(\"打七折划算\"); &#125; System.out.println(\"\"); &#125; public static double price1(double x, double y, double z) &#123; return mul(add(add(x,y), z), 0.7); &#125; public static double price2(double x, double y, double z) &#123; double min = Math.min(Math.min(x,y), z); return (sub(add(add(x,y), z), min)); &#125; public static double add(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2).doubleValue(); &#125; /** * 提供精确的减法运算。 * @param v1 被减数 * @param v2 减数 * @return 两个参数的差 */ public static double sub(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2).doubleValue(); &#125; /** * 提供精确的乘法运算。 * @param v1 被乘数 * @param v2 乘数 * @return 两个参数的积 */ public static double mul(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); &#125; &#125;","categories":[],"tags":[]},{"title":"docker常用命令记录","slug":"docker常用命令记录","date":"2017-06-15T08:06:48.000Z","updated":"2017-06-15T08:09:33.000Z","comments":true,"path":"2017/06/15/docker常用命令记录/","link":"","permalink":"http://yoursite.com/2017/06/15/docker常用命令记录/","excerpt":"","text":"docker exec -it mysql /bin/bash docker run -itd –name mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /docker/mysql:/var/lib/mysql:rw mysqldocker run -itd -p 16379:6379 –name myredis redis docker cp shiro_mysql.sql mysql:/tmp/shiro_mysql.sql sudo cp /Users/keithwang/Documents/workspace/Morning/project-doc/database/pussinboots_morning.sql /var/lib/docker/aufs/mnt/3e4a7efef8945e3b3f09e97f35303314df4dcd25a9fd08069e8671e93c2f6708/tmp/morning.sql","categories":[],"tags":[]},{"title":"git 常用操作","slug":"git-常用操作","date":"2017-06-15T07:57:59.000Z","updated":"2017-06-15T08:08:17.000Z","comments":true,"path":"2017/06/15/git-常用操作/","link":"","permalink":"http://yoursite.com/2017/06/15/git-常用操作/","excerpt":"","text":"git init git add README.md git commit -m “first commit” git remote add origin https://git.oschina.net/osckeithwang/hexogithubblog.git git push -u origin master git pull origin master —allow-unrelated-histories git fetch origin 远程分支名:本地分支名 mvn clean package -Dmaven.test.skip=true","categories":[],"tags":[]},{"title":"redis面试总结","slug":"redis面试总结","date":"2017-06-15T06:42:09.000Z","updated":"2017-06-15T06:49:06.000Z","comments":true,"path":"2017/06/15/redis面试总结/","link":"","permalink":"http://yoursite.com/2017/06/15/redis面试总结/","excerpt":"","text":"装载自：http://blog.csdn.net/guchuanyun111/article/category/6335900 什么是redis?Redis 是一个基于内存的高性能key-value数据库。 (有空再补充，有理解错误或不足欢迎指正) Reids的特点Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis支持的数据类型Redis通过Key-Value的单值不同类型来区分, 以下是支持的类型:StringsListsSets 求交集、并集Sorted Sethashes 为什么redis需要把所有数据放到内存中？Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。 Redis是单进程单线程的redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销 虚拟内存当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证. 自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库 分布式redis支持主从的模式。原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。 这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量 读写分离模型通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。 数据分片模型为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。 可以将每个节点看成都是独立的master，然后通过业务实现数据分片。 结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。 Redis的回收策略 volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据 使用Redis有哪些好处？ 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 支持丰富数据类型，支持string，list，set，sorted set，hash 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 redis相比memcached有哪些优势？ memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 redis的速度比memcached快很多 redis可以持久化其数据 redis常见性能问题和解决方案： Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 尽量避免在压力很大的主库上增加从库 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略： voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据 Memcache与Redis的区别都有哪些？1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。 2)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。 3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 4），value大小 redis最大可以达到1GB，而memcache只有1MB Redis 常见的性能问题都有哪些？如何解决？1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。 2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。 3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。 4). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内 redis 最适合的场景Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢? 如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点： 1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 2 、Redis支持数据的备份，即master-slave模式的数据备份。 3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 （1）、会话缓存（Session Cache） 最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。 （2）、全页缓存（FPC） 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。 此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 （3）、队列 Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。 （4），排行榜/计数器 Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 （5）、发布/订阅 最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。 Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。","categories":[],"tags":[]},{"title":"Java面试题记录","slug":"Java面试题记录","date":"2017-06-15T06:20:57.000Z","updated":"2017-06-21T09:49:28.000Z","comments":true,"path":"2017/06/15/Java面试题记录/","link":"","permalink":"http://yoursite.com/2017/06/15/Java面试题记录/","excerpt":"","text":"文思海辉 Spring 的IOC和AOP，实现原理 Spring的动态代理实现原理 MySql和Redis的区别，各自的运用场景 Dubbo的使用方式 一个线程开启了很多子线程，怎么判断所有的子线程都结束了？ 成都积微物联集团公司 Spring最大的优势是什么 activeMQ的实现方式，ActiveMQ的事务 MySql乐观锁悲观锁 MySql索引有几种方式，什么情况下，索引失效 HashSet和HashMap的区别，HashMap的实现方式 Spring的事务管理，Spring事务的传递性 Redis如果超过内存最大数怎么办？怎么设置redis的数据永不失效，Redis如何实现分页? Zookeeper的选举机制 dubbo降级 Spring怎么做重定向 Spring怎么返回json格式 Wait里面的代码抛出异常会释放锁对象吗 dubbo的版本 如果让你你写一个MVC框架，怎么实现","categories":[],"tags":[]},{"title":"一道线程面试题","slug":"一道线程面试题","date":"2017-06-15T06:08:49.000Z","updated":"2017-06-20T02:02:41.000Z","comments":true,"path":"2017/06/15/一道线程面试题/","link":"","permalink":"http://yoursite.com/2017/06/15/一道线程面试题/","excerpt":"","text":"今天接到文思海辉的电话面试，其中有一个问题是，如果一个线程，启动了很多子线程，怎么判断所有子线程都结束了？ 最笨的方法是，写一个共享变量i，每次子线性结束，共享变量i+1，并与线程数量比较，如果i的值和变量的值相等，则表明所有子线程都结束了。 还有一种方法，通过Callable接口的返回值。","categories":[],"tags":[]},{"title":"Spring动态代理","slug":"Spring动态代理","date":"2017-06-15T03:36:47.000Z","updated":"2017-06-15T03:39:04.000Z","comments":true,"path":"2017/06/15/Spring动态代理/","link":"","permalink":"http://yoursite.com/2017/06/15/Spring动态代理/","excerpt":"","text":"Java 动态代理https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/ Spring cglibhttps://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第六章 渲染WEB视图","slug":"Spring实战第四版读书笔记-第六章-渲染WEB视图","date":"2017-04-26T05:35:00.000Z","updated":"2017-04-26T05:40:32.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第六章-渲染WEB视图/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第六章-渲染WEB视图/","excerpt":"","text":"[TOC] #Spring实战第四版读书笔记—第六章 渲染Web视图 Spring定义类一个名为ViewResoler的接口，这个接口的定义如下：123public interface ViewResolver &#123; View resolveViewName(String viewName, Locale locale) throws Exception;&#125; 给resolveViewName方法传入一个视图名字和Locale对象时，它会返回一个View实例，View将输出结果渲染到response中12345678public interface View &#123; String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + \".responseStatus\"; String PATH_VARIABLES = View.class.getName() + \".pathVariables\"; String SELECTED_CONTENT_TYPE = View.class.getName() + \".selectedContentType\"; String getContentType(); void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;&#125; Spring自待类13个视图解析器，可以将逻辑视图名转化为物理实现 视图解析器 描述 BeanNameViewResolver 将视图解析为Spring应用上下文中的bean,其中bean的ID与视图名字相同 ContentNegtiatingViewResolver 通过考虑客户端需要的内容类型来解析视图，委托给另一个能够将视图解析为FreeMarker模版 InternalResourceViewResolver 将视图解析为WEB应用的内部资源（一般为JSP） JasperReportsViewResolver 将视图解析为JasperReports ResourceBundleViewResolver 将视图解析为资源Bundle（一般为属性文件） TitlesViewResolver 将视图解析为Apache Tile定义 UrlBasedViewResolver 之间根据视图名称解析视图，视图的名称会匹配一个物理视图的定义 VelocityLayoutViewResolver 将视图解析为Velocity布局 VelocityViewResolver 将视图解析为Velocity模版 XmlViewViewResolver 将视图解析为XML文件的bean定义。类似与BeanNameViewResolver XsltViewResourceViewResolver 将视图解析为XSLT转换后的结果","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第五章 Spring构建WEB应用","slug":"Spring实战第四版读书笔记-第五章-Spring构建WEB应用","date":"2017-04-26T05:34:44.000Z","updated":"2017-04-26T05:38:48.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第五章-Spring构建WEB应用/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第五章-Spring构建WEB应用/","excerpt":"","text":"[TOC] #构建Spring Web应用程序 Spring MVCSpring MVC 请求流程 请求—&gt; org.springframework.web.servlet.DispatcherServlet DispatcherServlet处理请求 DispatcherServlet —&gt;控制器 控制器 —&gt; 模型及逻辑视图名 模型及逻辑视图名 —&gt; DispatcherServlet DispatcherServlet —&gt;视图解析器 响应视图 —&gt; 用户 路径变量12345678@RequestMapping(method = RequestMethod.GET, value=\"/blog/&#123;id&#125;\") public ModelAndView blogDetail(@PathVariable(\"id\") Long id) throws Exception &#123; ModelAndView modelAndView = new ModelAndView(JspConstant.BLOG_ITEM); BlogArticle article = mBlogArticleService.getBy(id); modelAndView.addObject(ATTR_NAME_ARTICLE, article); return modelAndView; &#125; 参数验证123456789101112@RequestMapping(method = RequestMethod.POST, value=\"/blogAdd.do\") public ModelAndView blogAdd(HttpServletRequest request, @Valid BlogArticle article, Errors errors) throws Exception &#123; if(errors.hasErrors())&#123; return new ModelAndView(\"blog_add\"); &#125; mBlogArticleService.addArticle(article); ModelAndView modelAndView = new ModelAndView(\"redirect:/indexBlog.do\"); return modelAndView; &#125;","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第四章 面向切面","slug":"Spring实战第四版读书笔记-第四章-面向切面","date":"2017-04-26T05:34:25.000Z","updated":"2017-04-26T05:38:16.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第四章-面向切面/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第四章-面向切面/","excerpt":"","text":"[TOC] #第四章–面向切面的Spring 定义AOP术语通知 前置通知（Before） 后置通知（After） 返回通知（After-returning） 异常通知（After-throwing） 环绕通知（Around）连接点（Join Point） 切点（Pointcut）切面（Aspect）引入（Introduction）织入（Weaving）Spring 对AOP的支持Spring提供来4中类型的AOP支持 基于代理的经典AOP 纯POJO切面 @AspectJ 注解驱动的切面 注入式AspectJ切面 切点表达式语言定义切面 AspectJ指示器 描述 args() 限制连接点匹配参数为指定类型的执行方法 @args() 限制连接点匹配参数为指定注解类型的执行方法 execution() 用于匹配连接点的执行方法 this() 限制连接点匹配AOP代理的bean应用为指定类型的类 target 限制连接点匹配目标对象为为指定类型的类 @target 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解 within 限制连接点匹配指定的类型 @within 限制连接点匹配指定注解所标注的类型 @annotation 限制匹配带有指定注解的连接点 一个例子 遍写切点 12345package helloworld.com.dszy.spring.aop;public interface Performance &#123; void perform();&#125; 实现类 12345678@Componentpublic class JJPerformance implements Performance&#123; public void perform() &#123; System.out.println(&quot;JJ perform&quot;); &#125;&#125; 定义切面 1234567891011121314@Aspectpackage helloworld.com.dszy.spring.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class Audience &#123; @Before(&quot;execution(** helloworld.com.dszy.spring.aop.Performance.perform(..))&quot;) public void silenceCellPhone()&#123; System.out.println(&quot;call silenceCellPhone&quot;); &#125;&#125; 1234567891011121314151617package helloworld.com.dszy.spring.aop;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@EnableAspectJAutoProxy@ComponentScanpublic class ConertConfig &#123; @Bean public Audience audience() &#123; return new Audience(); &#125;&#125; 测试类12345678910111213141516171819202122package helloworld.com.dszy.spring.aop;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=ConertConfig.class)public class ConertTest &#123; @Autowired private Performance mPerformance; @Test public void testPerformance()&#123; mPerformance.perform(); &#125; &#125;","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第三章 高级装配","slug":"Spring实战第四版读书笔记-第三章-高级装配","date":"2017-04-26T05:34:04.000Z","updated":"2017-04-26T05:37:51.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第三章-高级装配/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第三章-高级装配/","excerpt":"","text":"[TOC] 第三章 高级装配环境与Profile解决多环境的情况下，如何一套代码又能很方便在多环境下切换。引入profile,在应用部署到每个环境诗，确保对应的profile处于激活（active）的状态 配置方式 配置写法 Java 配置 @Profile(“dev”) XML 配置 激活profile （参数spring.profiles.active 和spring.profiles.default） 作为DispatcherServlet的初始化参数 作为Web应用的上下文参数 作为JNDI条目 作为环境变量 作为JVM的系统参数 在集成测试类上使用@ActiveProfiles注解设置 条件化的Bean如果希望一个或者多个bean需要在满足某种条件的时候才创建，可以使用@Conditional注解配置使用方式： 实现org.springframework.context.annotation.condition接口 在bean上添加注解@Conditional(ACondition.class),其中ACondition.class实现了condition接口 自动装配的歧义性使用自动装配（@Autowired）是可能会产生歧义，这是应用被装配的对象可能在应用中会存在多个实现类，Spring容器无法确定需要装配的是哪一个类。解决方式： 标示首选Bean（@Primary） 限定自动装配的Bean (@Qualifier) Bean的作用域(Scope) 单例(Singleton) 原型(Prototype) 会话(Session) 请求(Request) 运行时值注入 注入外部的值（使用@PropertySource注解Environment） 解析属性占位符（PropertySourcesPlaceHolderConfigurer ${}）","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第二章 装配Bean","slug":"Spring实战第四版读书笔记-第二章-装配Bean","date":"2017-04-26T05:33:35.000Z","updated":"2017-04-26T05:37:18.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第二章-装配Bean/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第二章-装配Bean/","excerpt":"","text":"[TOC] Spring配置的可选方案建议尽可能少使用自动化配置，以避免显示配置带来的维护成本，如果确实需要显示配置的话，应该优先选择基于JAVA的配置，它比基于XML的配置更加强大，类型安全并且易于重构。 在XML中进行显示的配置123&lt;bean id=&quot;compactDisc&quot; class=&quot;org.baidu.CDPlayer&quot;&gt; &lt;constructor-arg ref=&quot;comactDisc&quot;&gt;&lt;/bean&gt; Spring util-命名空间的元素 元素 描述 引用一个类型为public static，并将其暴露为bean 创建一个java.util.List类型的bean,其中包含值和引用 创建一个java.util.Map类型的bean,其中包含值和引用 创建一个java.util.Properties类型的bean,其中包含值和引用 引用一个bean属性，并将其暴露为bean 创建一个java.util.Set类型的bean,其中包含值和引用 在JAVA中进行显示的配置@Bean(name=”beanName”) 隐式的Bean 发现机制和自动装配组件扫描（component scanning）:Spring会自动发现应用上下文中所创建的bean.@Component, @ComponentScan, @Configuration 自动装配（autowiring）:Spring自动满bean之间的依赖关系@Autowired, @Named 导入混合配置@Import（CDConfig.class)@ImportResource(“classpath:cd-config.xml”) @Autowired 和 @Name ，@Inject的区别是什么？","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第一章 Spring之旅","slug":"Spring实战第四版读书笔记-第一章-Spring之旅","date":"2017-04-26T05:33:15.000Z","updated":"2017-04-26T05:36:45.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第一章-Spring之旅/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第一章-Spring之旅/","excerpt":"","text":"[TOC] 简化JAVA开发 基于POJO的轻量级和最小侵入性编程 基于依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和切面和模版减少样板代码 依赖注入（DI）Spring通过依赖注入实现JAVA BEAN（组件）之间的解耦 Spring上下文Spring通过上下文（Application Context）装载Bean的定义并把它们组装起来，Spring上下文全权负责对象的创建和组装。Spring自带了许多种应用上下文的实现，如ClassPathXmlApplicationContext类。 应用切面（AOP，Aspect Oriented Programming）DI让各个组件保持松耦合，而AOP把遍布应用各处的功能分离出来，形成可重用的组件。AOP让各个组件专注与自己的核心业务实现，而将各个组件共同的功能（如日志，事物管理，安全等）通过AOP技术切入到这些组件中，实现功能分离，组件重用。 模版技术使用模版消除样板式代码（如JdbcTemplate) Spring 容器Spring容器负责对象的创建和销毁，配置并管理对象的生命周期。Spring自带类多个容器实现，可以归纳为两种不同的类型。 Bean工厂（org.springframework.beans.factory.beanFactory） 应用上下文（org.springframework.context.ApplicationContext）AnnotationConfigApplicationContextAnnotationConfigWebApplicationContextClassPathXmlApplicationContextFileSystemXmlApplicationContextXmlWebApplicationContext Bean的生命周期1，实例化2，填充属性3，调用BeanNameAware的setBeanFactory()方法4，调用BeanFactoryAware的setBeanFactory()方法5，调用ApplicationContextAware的setApplicationContext()方法6，调用BeanPostProcessor的预初始化方法7，盗用InitializingBean的afterPropertiesSet方法8，调用自定义的初始化方法9，调用BeanPostProcessor的初始化方法10，Bean可以使用了11，关闭容器12，调用DisposableBean的destroy()方法13，调用自定义的销毁方法 Spring生态圈 Spring核心容器 Spring的AOP模块 数据访问和集成 Instrumentation Spring Web Flow Spring Web Service Spring Security Spring Integration Spring Batch Spring Data Spring Social Spring Mobile Spring for Android Spring Boot","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-04-25T03:05:17.000Z","updated":"2017-04-25T03:05:17.000Z","comments":true,"path":"2017/04/25/hello-world/","link":"","permalink":"http://yoursite.com/2017/04/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}