{"meta":{"title":"Keith Wang的个人博客","subtitle":null,"description":null,"author":"Keith Wang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Spring动态代理","slug":"Spring动态代理","date":"2017-06-15T03:36:47.000Z","updated":"2017-06-15T03:39:04.000Z","comments":true,"path":"2017/06/15/Spring动态代理/","link":"","permalink":"http://yoursite.com/2017/06/15/Spring动态代理/","excerpt":"","text":"Java 动态代理https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/ Spring cglibhttps://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第六章 渲染WEB视图","slug":"Spring实战第四版读书笔记-第六章-渲染WEB视图","date":"2017-04-26T05:35:00.000Z","updated":"2017-04-26T05:40:32.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第六章-渲染WEB视图/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第六章-渲染WEB视图/","excerpt":"","text":"[TOC] #Spring实战第四版读书笔记—第六章 渲染Web视图 Spring定义类一个名为ViewResoler的接口，这个接口的定义如下：123public interface ViewResolver &#123; View resolveViewName(String viewName, Locale locale) throws Exception;&#125; 给resolveViewName方法传入一个视图名字和Locale对象时，它会返回一个View实例，View将输出结果渲染到response中12345678public interface View &#123; String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + \".responseStatus\"; String PATH_VARIABLES = View.class.getName() + \".pathVariables\"; String SELECTED_CONTENT_TYPE = View.class.getName() + \".selectedContentType\"; String getContentType(); void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;&#125; Spring自待类13个视图解析器，可以将逻辑视图名转化为物理实现 视图解析器 描述 BeanNameViewResolver 将视图解析为Spring应用上下文中的bean,其中bean的ID与视图名字相同 ContentNegtiatingViewResolver 通过考虑客户端需要的内容类型来解析视图，委托给另一个能够将视图解析为FreeMarker模版 InternalResourceViewResolver 将视图解析为WEB应用的内部资源（一般为JSP） JasperReportsViewResolver 将视图解析为JasperReports ResourceBundleViewResolver 将视图解析为资源Bundle（一般为属性文件） TitlesViewResolver 将视图解析为Apache Tile定义 UrlBasedViewResolver 之间根据视图名称解析视图，视图的名称会匹配一个物理视图的定义 VelocityLayoutViewResolver 将视图解析为Velocity布局 VelocityViewResolver 将视图解析为Velocity模版 XmlViewViewResolver 将视图解析为XML文件的bean定义。类似与BeanNameViewResolver XsltViewResourceViewResolver 将视图解析为XSLT转换后的结果","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第五章 Spring构建WEB应用","slug":"Spring实战第四版读书笔记-第五章-Spring构建WEB应用","date":"2017-04-26T05:34:44.000Z","updated":"2017-04-26T05:38:48.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第五章-Spring构建WEB应用/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第五章-Spring构建WEB应用/","excerpt":"","text":"[TOC] #构建Spring Web应用程序 Spring MVCSpring MVC 请求流程 请求—&gt; org.springframework.web.servlet.DispatcherServlet DispatcherServlet处理请求 DispatcherServlet —&gt;控制器 控制器 —&gt; 模型及逻辑视图名 模型及逻辑视图名 —&gt; DispatcherServlet DispatcherServlet —&gt;视图解析器 响应视图 —&gt; 用户 路径变量12345678@RequestMapping(method = RequestMethod.GET, value=\"/blog/&#123;id&#125;\") public ModelAndView blogDetail(@PathVariable(\"id\") Long id) throws Exception &#123; ModelAndView modelAndView = new ModelAndView(JspConstant.BLOG_ITEM); BlogArticle article = mBlogArticleService.getBy(id); modelAndView.addObject(ATTR_NAME_ARTICLE, article); return modelAndView; &#125; 参数验证123456789101112@RequestMapping(method = RequestMethod.POST, value=\"/blogAdd.do\") public ModelAndView blogAdd(HttpServletRequest request, @Valid BlogArticle article, Errors errors) throws Exception &#123; if(errors.hasErrors())&#123; return new ModelAndView(\"blog_add\"); &#125; mBlogArticleService.addArticle(article); ModelAndView modelAndView = new ModelAndView(\"redirect:/indexBlog.do\"); return modelAndView; &#125;","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第四章 面向切面","slug":"Spring实战第四版读书笔记-第四章-面向切面","date":"2017-04-26T05:34:25.000Z","updated":"2017-04-26T05:38:16.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第四章-面向切面/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第四章-面向切面/","excerpt":"","text":"[TOC] #第四章–面向切面的Spring 定义AOP术语通知 前置通知（Before） 后置通知（After） 返回通知（After-returning） 异常通知（After-throwing） 环绕通知（Around）连接点（Join Point） 切点（Pointcut）切面（Aspect）引入（Introduction）织入（Weaving）Spring 对AOP的支持Spring提供来4中类型的AOP支持 基于代理的经典AOP 纯POJO切面 @AspectJ 注解驱动的切面 注入式AspectJ切面 切点表达式语言定义切面 AspectJ指示器 描述 args() 限制连接点匹配参数为指定类型的执行方法 @args() 限制连接点匹配参数为指定注解类型的执行方法 execution() 用于匹配连接点的执行方法 this() 限制连接点匹配AOP代理的bean应用为指定类型的类 target 限制连接点匹配目标对象为为指定类型的类 @target 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解 within 限制连接点匹配指定的类型 @within 限制连接点匹配指定注解所标注的类型 @annotation 限制匹配带有指定注解的连接点 一个例子 遍写切点 12345package helloworld.com.dszy.spring.aop;public interface Performance &#123; void perform();&#125; 实现类 12345678@Componentpublic class JJPerformance implements Performance&#123; public void perform() &#123; System.out.println(&quot;JJ perform&quot;); &#125;&#125; 定义切面 1234567891011121314@Aspectpackage helloworld.com.dszy.spring.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class Audience &#123; @Before(&quot;execution(** helloworld.com.dszy.spring.aop.Performance.perform(..))&quot;) public void silenceCellPhone()&#123; System.out.println(&quot;call silenceCellPhone&quot;); &#125;&#125; 1234567891011121314151617package helloworld.com.dszy.spring.aop;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@EnableAspectJAutoProxy@ComponentScanpublic class ConertConfig &#123; @Bean public Audience audience() &#123; return new Audience(); &#125;&#125; 测试类12345678910111213141516171819202122package helloworld.com.dszy.spring.aop;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=ConertConfig.class)public class ConertTest &#123; @Autowired private Performance mPerformance; @Test public void testPerformance()&#123; mPerformance.perform(); &#125; &#125;","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第三章 高级装配","slug":"Spring实战第四版读书笔记-第三章-高级装配","date":"2017-04-26T05:34:04.000Z","updated":"2017-04-26T05:37:51.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第三章-高级装配/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第三章-高级装配/","excerpt":"","text":"[TOC] 第三章 高级装配环境与Profile解决多环境的情况下，如何一套代码又能很方便在多环境下切换。引入profile,在应用部署到每个环境诗，确保对应的profile处于激活（active）的状态 配置方式 配置写法 Java 配置 @Profile(“dev”) XML 配置 激活profile （参数spring.profiles.active 和spring.profiles.default） 作为DispatcherServlet的初始化参数 作为Web应用的上下文参数 作为JNDI条目 作为环境变量 作为JVM的系统参数 在集成测试类上使用@ActiveProfiles注解设置 条件化的Bean如果希望一个或者多个bean需要在满足某种条件的时候才创建，可以使用@Conditional注解配置使用方式： 实现org.springframework.context.annotation.condition接口 在bean上添加注解@Conditional(ACondition.class),其中ACondition.class实现了condition接口 自动装配的歧义性使用自动装配（@Autowired）是可能会产生歧义，这是应用被装配的对象可能在应用中会存在多个实现类，Spring容器无法确定需要装配的是哪一个类。解决方式： 标示首选Bean（@Primary） 限定自动装配的Bean (@Qualifier) Bean的作用域(Scope) 单例(Singleton) 原型(Prototype) 会话(Session) 请求(Request) 运行时值注入 注入外部的值（使用@PropertySource注解Environment） 解析属性占位符（PropertySourcesPlaceHolderConfigurer ${}）","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第二章 装配Bean","slug":"Spring实战第四版读书笔记-第二章-装配Bean","date":"2017-04-26T05:33:35.000Z","updated":"2017-04-26T05:37:18.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第二章-装配Bean/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第二章-装配Bean/","excerpt":"","text":"[TOC] Spring配置的可选方案建议尽可能少使用自动化配置，以避免显示配置带来的维护成本，如果确实需要显示配置的话，应该优先选择基于JAVA的配置，它比基于XML的配置更加强大，类型安全并且易于重构。 在XML中进行显示的配置123&lt;bean id=&quot;compactDisc&quot; class=&quot;org.baidu.CDPlayer&quot;&gt; &lt;constructor-arg ref=&quot;comactDisc&quot;&gt;&lt;/bean&gt; Spring util-命名空间的元素 元素 描述 引用一个类型为public static，并将其暴露为bean 创建一个java.util.List类型的bean,其中包含值和引用 创建一个java.util.Map类型的bean,其中包含值和引用 创建一个java.util.Properties类型的bean,其中包含值和引用 引用一个bean属性，并将其暴露为bean 创建一个java.util.Set类型的bean,其中包含值和引用 在JAVA中进行显示的配置@Bean(name=”beanName”) 隐式的Bean 发现机制和自动装配组件扫描（component scanning）:Spring会自动发现应用上下文中所创建的bean.@Component, @ComponentScan, @Configuration 自动装配（autowiring）:Spring自动满bean之间的依赖关系@Autowired, @Named 导入混合配置@Import（CDConfig.class)@ImportResource(“classpath:cd-config.xml”) @Autowired 和 @Name ，@Inject的区别是什么？","categories":[],"tags":[]},{"title":"Spring实战第四版读书笔记-第一章 Spring之旅","slug":"Spring实战第四版读书笔记-第一章-Spring之旅","date":"2017-04-26T05:33:15.000Z","updated":"2017-04-26T05:36:45.000Z","comments":true,"path":"2017/04/26/Spring实战第四版读书笔记-第一章-Spring之旅/","link":"","permalink":"http://yoursite.com/2017/04/26/Spring实战第四版读书笔记-第一章-Spring之旅/","excerpt":"","text":"[TOC] 简化JAVA开发 基于POJO的轻量级和最小侵入性编程 基于依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和切面和模版减少样板代码 依赖注入（DI）Spring通过依赖注入实现JAVA BEAN（组件）之间的解耦 Spring上下文Spring通过上下文（Application Context）装载Bean的定义并把它们组装起来，Spring上下文全权负责对象的创建和组装。Spring自带了许多种应用上下文的实现，如ClassPathXmlApplicationContext类。 应用切面（AOP，Aspect Oriented Programming）DI让各个组件保持松耦合，而AOP把遍布应用各处的功能分离出来，形成可重用的组件。AOP让各个组件专注与自己的核心业务实现，而将各个组件共同的功能（如日志，事物管理，安全等）通过AOP技术切入到这些组件中，实现功能分离，组件重用。 模版技术使用模版消除样板式代码（如JdbcTemplate) Spring 容器Spring容器负责对象的创建和销毁，配置并管理对象的生命周期。Spring自带类多个容器实现，可以归纳为两种不同的类型。 Bean工厂（org.springframework.beans.factory.beanFactory） 应用上下文（org.springframework.context.ApplicationContext）AnnotationConfigApplicationContextAnnotationConfigWebApplicationContextClassPathXmlApplicationContextFileSystemXmlApplicationContextXmlWebApplicationContext Bean的生命周期1，实例化2，填充属性3，调用BeanNameAware的setBeanFactory()方法4，调用BeanFactoryAware的setBeanFactory()方法5，调用ApplicationContextAware的setApplicationContext()方法6，调用BeanPostProcessor的预初始化方法7，盗用InitializingBean的afterPropertiesSet方法8，调用自定义的初始化方法9，调用BeanPostProcessor的初始化方法10，Bean可以使用了11，关闭容器12，调用DisposableBean的destroy()方法13，调用自定义的销毁方法 Spring生态圈 Spring核心容器 Spring的AOP模块 数据访问和集成 Instrumentation Spring Web Flow Spring Web Service Spring Security Spring Integration Spring Batch Spring Data Spring Social Spring Mobile Spring for Android Spring Boot","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-04-25T03:05:17.000Z","updated":"2017-04-25T03:05:17.000Z","comments":true,"path":"2017/04/25/hello-world/","link":"","permalink":"http://yoursite.com/2017/04/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}